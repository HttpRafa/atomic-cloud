use std::{cell::UnsafeCell, fs, rc::Rc, sync::RwLock};

use cloudlet::LocalCloudlet;
use common::allocator::NumberAllocator;
use config::Config;
use template::Templates;

use crate::{
    error,
    exports::cloudlet::driver::bridge::{
        Capabilities, GenericCloudlet, GuestGenericCloudlet, GuestGenericDriver, Information,
        RemoteController,
    },
    info,
    storage::Storage,
};

pub mod cloudlet;
mod config;
mod template;

// Include the build information generated by build.rs
include!(concat!(env!("OUT_DIR"), "/build_info.rs"));

pub const AUTHORS: [&str; 1] = ["HttpRafa"];

pub struct Local {
    /* Cloud Identification */
    cloud_identifier: String,

    /* Config */
    config: UnsafeCell<Option<Rc<Config>>>,

    /* Shared Resources */
    port_allocator: UnsafeCell<Option<Rc<RwLock<NumberAllocator<u16>>>>>,

    /* Templates */
    templates: Rc<RwLock<Templates>>,

    /* Cloudlets that this driver handles */
    cloudlets: RwLock<Vec<Rc<LocalCloudlet>>>,
}

impl Local {
    fn get_config(&self) -> &Rc<Config> {
        // Safe as we are only borrowing the reference immutably
        unsafe { &*self.config.get() }.as_ref().unwrap()
    }
    fn get_port_allocator(&self) -> &Rc<RwLock<NumberAllocator<u16>>> {
        // Safe as we are only borrowing the reference immutably
        unsafe { &*self.port_allocator.get() }.as_ref().unwrap()
    }
}

impl GuestGenericDriver for Local {
    fn new(cloud_identifier: String) -> Self {
        Self {
            cloud_identifier,
            config: UnsafeCell::new(None),
            port_allocator: UnsafeCell::new(None),
            templates: Rc::new(RwLock::new(Templates::new())),
            cloudlets: RwLock::new(Vec::new()),
        }
    }

    fn init(&self) -> Information {
        let mut ready = true;

        let tmp_dir = Storage::get_temporary_folder();
        if tmp_dir.exists() {
            if let Err(error) = fs::remove_dir_all(tmp_dir) {
                error!(
                    "<red>Failed</> to remove temporary directory: <red>{}</>",
                    error
                );
                ready = false;
            }
        }

        // Load configuration
        {
            let config = Config::new_filled();
            let allocator = NumberAllocator::new(config.ports.clone());
            unsafe {
                *self.config.get() = Some(Rc::new(config));
                *self.port_allocator.get() = Some(Rc::new(RwLock::new(allocator)));
            }
        }

        // Load all templates
        {
            let mut templates = self
                .templates
                .write()
                .expect("Failed to get lock on templates");
            templates.load_all();
            templates.prepare_all();
        }

        Information {
            authors: AUTHORS.iter().map(|&author| author.to_string()).collect(),
            version: VERSION.to_string(),
            ready,
        }
    }

    fn init_cloudlet(
        &self,
        name: String,
        capabilities: Capabilities,
        controller: RemoteController,
    ) -> Result<GenericCloudlet, String> {
        let wrapper = LocalCloudletWrapper::new(
            self.cloud_identifier.clone(),
            name.clone(),
            None,
            capabilities,
            controller,
        );
        unsafe {
            *wrapper.inner.config.get() = Some(self.get_config().clone());
            *wrapper.inner.port_allocator.get() = Some(self.get_port_allocator().clone());
            *wrapper.inner.templates.get() = Some(self.templates.clone());
        }
        // Add cloudlet to cloudlets list
        let mut cloudlets = self
            .cloudlets
            .write()
            .expect("Failed to get lock on cloudlets");
        cloudlets.push(wrapper.inner.clone());
        info!("Cloudlet <blue>{}</> was <green>added</>", name);
        Ok(GenericCloudlet::new(wrapper))
    }
}

pub struct LocalCloudletWrapper {
    pub inner: Rc<LocalCloudlet>,
}

impl LocalCloudletWrapper {
    fn _get_config(&self) -> &Rc<Config> {
        // Safe as we are only borrowing the reference immutably
        unsafe { &*self.inner.config.get() }.as_ref().unwrap()
    }
    fn get_templates(&self) -> &Rc<RwLock<Templates>> {
        // Safe as we are only borrowing the reference immutably
        unsafe { &*self.inner.templates.get() }.as_ref().unwrap()
    }
    fn get_port_allocator(&self) -> &Rc<RwLock<NumberAllocator<u16>>> {
        // Safe as we are only borrowing the reference immutably
        unsafe { &*self.inner.port_allocator.get() }
            .as_ref()
            .unwrap()
    }
}
