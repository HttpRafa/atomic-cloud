use std::{fs, rc::Rc, sync::RwLock};

use cloudlet::LocalCloudlet;
use template::Templates;

use crate::{
    error,
    exports::cloudlet::driver::bridge::{
        Capabilities, GenericCloudlet, GuestGenericCloudlet, GuestGenericDriver, Information,
        RemoteController,
    },
    info,
    storage::Storage,
};

pub mod cloudlet;
mod template;

// Include the build information generated by build.rs
include!(concat!(env!("OUT_DIR"), "/build_info.rs"));

pub const AUTHORS: [&str; 1] = ["HttpRafa"];

pub struct Local {
    /* Cloud Identification */
    cloud_identifier: String,

    /* Templates */
    templates: RwLock<Templates>,

    /* Cloudlets that this driver handles */
    cloudlets: RwLock<Vec<Rc<LocalCloudlet>>>,
}

impl GuestGenericDriver for Local {
    fn new(cloud_identifier: String) -> Self {
        Self {
            cloud_identifier,
            templates: RwLock::new(Templates::new()),
            cloudlets: RwLock::new(Vec::new()),
        }
    }

    fn init(&self) -> Information {
        let mut ready = true;

        let tmp_dir = Storage::get_temporary_folder();
        if tmp_dir.exists() {
            if let Err(error) = fs::remove_dir_all(tmp_dir) {
                error!(
                    "<red>Failed</> to remove temporary directory: <red>{}</>",
                    error
                );
                ready = false;
            }
        }

        // Load all templates
        {
            let mut templates = self
                .templates
                .write()
                .expect("Failed to get lock on templates");
            templates.load_all();
            templates.prepare_all();
        }

        Information {
            authors: AUTHORS.iter().map(|&author| author.to_string()).collect(),
            version: VERSION.to_string(),
            ready,
        }
    }

    fn init_cloudlet(
        &self,
        name: String,
        capabilities: Capabilities,
        controller: RemoteController,
    ) -> Result<GenericCloudlet, String> {
        let wrapper = LocalCloudletWrapper::new(
            self.cloud_identifier.clone(),
            name.clone(),
            None,
            capabilities,
            controller,
        );
        // Add cloudlet to cloudlets list
        let mut cloudlets = self
            .cloudlets
            .write()
            .expect("Failed to get lock on cloudlets");
        cloudlets.push(wrapper.inner.clone());
        info!("Cloudlet <blue>{}</> was <green>added</>", name);
        Ok(GenericCloudlet::new(wrapper))
    }
}

pub struct LocalCloudletWrapper {
    pub inner: Rc<LocalCloudlet>,
}
