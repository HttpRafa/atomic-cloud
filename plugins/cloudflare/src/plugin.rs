use std::{
    cell::RefCell,
    rc::Rc,
    time::{Duration, Instant},
};

use anyhow::Result;

use backend::Backend;
use batcher::Batcher;
use config::Config;
use dns::manager::Records;

use crate::{
    error,
    generated::{
        exports::plugin::system::{
            bridge::{
                Capabilities, ErrorMessage, GuestPlugin, Information, Listener as GenericListener,
                Node as GenericNode, ScopedErrors,
            },
            event::Events,
        },
        plugin::system::data_types::Features,
    },
    listener::Listener,
};

pub mod backend;
pub mod batcher;
pub mod config;
pub mod dns;
pub mod math;

// Include the build information generated by build.rs
include!(concat!(env!("OUT_DIR"), "/build_info.rs"));

pub const AUTHORS: [&str; 1] = ["HttpRafa"];
pub const FEATURES: Features = Features::LISTENER;

pub struct Cloudflare {
    /* Configuration */
    config: RefCell<Config>,

    /* Batcher */
    batcher: Rc<RefCell<Batcher>>,

    /* Managers */
    backend: RefCell<Backend>,
    records: RefCell<Records>,

    /* Tick Intervals */
    last: RefCell<Instant>,
}

impl GuestPlugin for Cloudflare {
    fn new(_: String) -> Self {
        Self {
            config: RefCell::new(Config::default()), // Dummy config
            batcher: Rc::new(RefCell::new(Batcher::default())),
            backend: RefCell::new(Backend::default()),
            records: RefCell::new(Records::default()),
            last: RefCell::new(Instant::now()),
        }
    }

    fn init(&self) -> Information {
        fn inner(own: &Cloudflare) -> Result<()> {
            // Load configuration
            {
                let config = Config::parse()?;
                own.backend.replace(Backend::new(&config));
                own.records.replace(Records::new(&config));
                own.config.replace(config);
            }
            Ok(())
        }

        Information {
            authors: AUTHORS.iter().map(|author| (*author).to_string()).collect(),
            version: VERSION.to_string(),
            features: FEATURES,
            ready: if let Err(error) = inner(self) {
                error!("Failed to initialize plugin: {}", error);
                false
            } else {
                true
            },
        }
    }

    fn init_listener(&self) -> (Events, GenericListener) {
        (
            Events::SERVER_STOP | Events::SERVER_CHANGE_READY,
            GenericListener::new(Listener::new(
                &self.config.borrow().entries,
                self.batcher.clone(),
            )),
        )
    }

    fn init_node(
        &self,
        _: String,
        _: Capabilities,
        _: String,
    ) -> Result<GenericNode, ErrorMessage> {
        unimplemented!()
    }

    fn tick(&self) -> Result<(), ScopedErrors> {
        if self.last.borrow().elapsed()
            >= Duration::from_secs(60 / u64::from(self.config.borrow().rate))
        {
            self.last.replace(Instant::now());

            // Execute update
            self.records
                .borrow_mut()
                .tick(&self.backend.borrow(), &mut self.batcher.borrow_mut());
        }
        Ok(())
    }

    fn shutdown(&self) -> Result<(), ScopedErrors> {
        self.records.borrow_mut().shutdown(&self.backend.borrow());
        Ok(())
    }
}
