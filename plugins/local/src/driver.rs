use std::{cell::UnsafeCell, fs, rc::Rc, sync::RwLock, time::Instant};

use cloudlet::LocalCloudlet;
use common::{allocator::NumberAllocator, tick::TickResult};
use config::{Config, CLEANUP_TIMEOUT};
use template::Templates;

use crate::{
    cloudlet::driver::{
        file::remove_dir_all,
        types::{ErrorMessage, ScopedErrors},
    },
    debug, error,
    exports::cloudlet::driver::bridge::{
        Capabilities, GenericCloudlet, GuestGenericCloudlet, GuestGenericDriver, Information,
        RemoteController,
    },
    info,
    storage::Storage,
};

pub mod cloudlet;
mod config;
mod template;

// Include the build information generated by build.rs
include!(concat!(env!("OUT_DIR"), "/build_info.rs"));

pub const AUTHORS: [&str; 1] = ["HttpRafa"];

pub struct Local {
    /* Cloud Identification */
    cloud_identifier: String,

    /* Config */
    config: UnsafeCell<Option<Rc<Config>>>,

    /* Shared Resources */
    port_allocator: UnsafeCell<Option<Rc<RwLock<NumberAllocator<u16>>>>>,

    /* Templates */
    templates: Rc<RwLock<Templates>>,

    /* Cloudlets that this driver handles */
    cloudlets: RwLock<Vec<Rc<LocalCloudlet>>>,
}

impl Local {
    fn get_config(&self) -> &Rc<Config> {
        // Safe as we are only borrowing the reference immutably
        unsafe { &*self.config.get() }.as_ref().unwrap()
    }
    fn get_port_allocator(&self) -> &Rc<RwLock<NumberAllocator<u16>>> {
        // Safe as we are only borrowing the reference immutably
        unsafe { &*self.port_allocator.get() }.as_ref().unwrap()
    }
}

impl GuestGenericDriver for Local {
    fn new(cloud_identifier: String) -> Self {
        Self {
            cloud_identifier,
            config: UnsafeCell::new(None),
            port_allocator: UnsafeCell::new(None),
            templates: Rc::new(RwLock::new(Templates::new())),
            cloudlets: RwLock::new(Vec::new()),
        }
    }

    fn init(&self) -> Information {
        let mut ready = true;

        let tmp_dir = Storage::get_temporary_folder();
        debug!("Checking directories...");
        if tmp_dir.exists() {
            if let Err(error) = remove_dir_all(&Storage::get_temporary_folder_host_converted()) {
                error!(
                    "<red>Failed</> to remove temporary directory: <red>{}</>",
                    error
                );
                ready = false;
            }
        }
        debug!("Directories are ready");

        // Load configuration
        {
            let config = Config::new_filled();
            let allocator = NumberAllocator::new(config.ports.clone());
            unsafe {
                *self.config.get() = Some(Rc::new(config));
                *self.port_allocator.get() = Some(Rc::new(RwLock::new(allocator)));
            }
        }

        // Load all templates
        {
            let mut templates = self
                .templates
                .write()
                .expect("Failed to get lock on templates");
            templates.load_all();
            templates.prepare_all();
        }

        Information {
            authors: AUTHORS.iter().map(|&author| author.to_string()).collect(),
            version: VERSION.to_string(),
            ready,
        }
    }

    fn init_cloudlet(
        &self,
        name: String,
        capabilities: Capabilities,
        controller: RemoteController,
    ) -> Result<GenericCloudlet, ErrorMessage> {
        let wrapper = LocalCloudletWrapper::new(
            self.cloud_identifier.clone(),
            name.clone(),
            None,
            capabilities,
            controller,
        );
        unsafe {
            *wrapper.inner.config.get() = Some(self.get_config().clone());
            *wrapper.inner.port_allocator.get() = Some(self.get_port_allocator().clone());
            *wrapper.inner.templates.get() = Some(self.templates.clone());
        }
        // Add cloudlet to cloudlets list
        let mut cloudlets = self
            .cloudlets
            .write()
            .expect("Failed to get lock on cloudlets");
        cloudlets.push(wrapper.inner.clone());
        info!("Cloudlet <blue>{}</> was <green>added</>", name);
        Ok(GenericCloudlet::new(wrapper))
    }

    fn cleanup(&self) -> Result<(), ScopedErrors> {
        let cloudlets = self
            .cloudlets
            .read()
            .expect("Failed to get lock on cloudlets");
        info!("Starting cleanup process...");
        let start_time = Instant::now();
        let mut last_attempt = false;

        while !last_attempt {
            if start_time.elapsed() > CLEANUP_TIMEOUT {
                last_attempt = true;
            }

            let all_stopped = cloudlets.iter().try_fold(true, |all_stopped, cloudlet| {
                match cloudlet.try_exit(last_attempt) {
                    Ok(TickResult::Ok) => Ok(false),
                    Ok(_) => Ok(all_stopped),
                    Err(error) => Err(error),
                }
            })?;

            if all_stopped {
                break;
            }
        }

        info!("All units should be <red>stopped</> now. Removing temporary files...");
        if let Err(error) = fs::remove_dir_all(Storage::get_temporary_folder()) {
            error!("<red>Failed</> to remove temporary directory: {}", error);
        }
        info!("Driver cleanup <green>finished</>");
        Ok(())
    }

    fn tick(&self) -> Result<(), ScopedErrors> {
        Ok(())
    }
}

pub struct LocalCloudletWrapper {
    pub inner: Rc<LocalCloudlet>,
}
