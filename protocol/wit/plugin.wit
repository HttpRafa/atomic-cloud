package plugin:system;

interface types {
    type error-message = string;
    type scoped-errors = list<scoped-error>;

    record scoped-error {
        scope: string,
        message: error-message,
    }

    variant reference {
        controller,
        configs,
        data,
    }

    record directory {
        path: string,
        reference: reference,
    }

    record key-value {
        key: string,
        value: string,
    }
}

interface log {
    variant level {
        debug,
        info,
        warn,
        error,
    }
    log-string: func(level: level, message: string);
}

interface platform {
    variant os {
        unix,
        windows,
    }
    get-os: func() -> os;
}

interface file {
    use types.{error-message, directory};
    remove-dir-all: func(directory: directory) -> result<_, error-message>;
}

interface http {
    variant method {
        get,
        patch,
        post,
        put,
        delete,
    }

    record header {
        key: string,
        value: string,
    }

    record response {
        status-code: u32,
        reason-phrase: string,
        headers: list<header>,
        bytes: list<u8>,
    }

    send-http-request: func(method: method, url: string, headers: list<header>, body: option<list<u8>>) -> option<response>;
}

interface process {
    use types.{error-message, key-value, directory};

    variant reader-mode {
        direct,
        async,
    }

    variant std-reader {
        stdout,
        stderr,
    }

    spawn-process: func(command: string, args: list<string>, environment: list<key-value>, directory: directory, mode: reader-mode) -> result<u32, error-message>;
    kill-process: func(pid: u32) -> result<_, error-message>;
    drop-process: func(pid: u32) -> result<bool, error-message>;
    try-wait: func(pid: u32) -> result<option<s32>, error-message>;
    read-direct: func(pid: u32, buf-size: u32, std: std-reader) -> result<tuple<u32, list<u8>>, error-message>;
    read-to-end-direct: func(pid: u32, std: std-reader) -> result<tuple<u32, list<u8>>, error-message>;
    read-line-direct: func(pid: u32, std: std-reader) -> result<tuple<u32, string>, error-message>;
    read-line-async: func(pid: u32, std: std-reader) -> result<option<string>, error-message>;
    write-stdin: func(pid: u32, data: list<u8>) -> result<_, error-message>;
}

interface bridge {
    use types.{error-message, scoped-errors, key-value};

    type uuid = string;

    record information {
        authors: list<string>,
        version: string,
        ready: bool,
    }

    record capabilities {
        memory: option<u32>,
        max-allocations: option<u32>,
        child: option<string>,
    }

    record remote-controller {
        address: string,
    }

    record address {
        host: string,
        port: u16,
    }

    record resources {
        memory: u32,
        swap: u32,
        cpu: u32,
        io: u32,
        disk: u32,
        addresses: u32,
    }

    record setting {
        key: string,
        value: string,
    }

    variant retention {
        permanent,
        temporary,
    }

    record spec {
        settings: list<key-value>,
        environment: list<key-value>,
        disk-retention: retention,
        image: string,
    }

    record allocation {
        addresses: list<address>,
        resources: resources,
        spec: spec,
    }

    record auth {
        token: string,
    }

    record server-proposal {
        name: string,
        deployment: option<string>,
        resources: resources,
        spec: spec,
    }

    record server {
        name: string,
        uuid: uuid,
        deployment: option<string>,
        allocation: allocation,
        auth: auth,
    }

    resource generic-node {
        constructor(cloud-identifier: string, name: string, id: option<u32>, capabilities: capabilities, controller: remote-controller);
        tick: func() -> result<_, scoped-errors>;
        allocate-addresses: func(server: server-proposal) -> result<list<address>, error-message>;
        deallocate-addresses: func(addresses: list<address>);
        start-server: func(server: server);
        restart-server: func(server: server);
        stop-server: func(server: server);
    }

    resource generic-plugin {
        constructor(cloud-identifier: string);
        init: func() -> information;
        init-node: func(name: string, capabilities: capabilities, controller: remote-controller) -> result<generic-node, error-message>;
        tick: func() -> result<_, scoped-errors>;
        shutdown: func() -> result<_, scoped-errors>;
    }
}

world plugin {
    export bridge;
    import log;
    import platform;
    import file;
    import http;
    //import process;
}